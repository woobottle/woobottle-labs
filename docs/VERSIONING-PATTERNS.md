# S3 버저닝 패턴 가이드

## 현재 구현: 폴더 기반 버저닝

### 구조
```
s3://woo-bottle.com/
├── versions/
│   ├── v1.0.0/          # 아카이브 버전들
│   ├── v1.0.1/
│   └── v1.0.2/
└── current/             # 활성 버전 (루트에서 리다이렉트)
```

### 장점
- ✅ 직관적이고 이해하기 쉬움
- ✅ 각 버전을 명시적으로 관리
- ✅ 롤백이 간단 (폴더 복사)
- ✅ 버전별 직접 접근 가능
- ✅ 웹사이트 호스팅과 자연스러운 통합

### 단점
- ❌ 스토리지 사용량 증가 (중복 저장)
- ❌ 배포 시간 증가 (전체 파일 복사)

## 대안 패턴들

### 1. S3 Native Versioning
AWS의 기본 버저닝 기능 사용

**구조:**
```
s3://bucket/index.html (version-id: abc123)
s3://bucket/index.html (version-id: def456)
s3://bucket/about.html (version-id: xyz789)
```

**장점:**
- AWS 네이티브 기능
- 스토리지 효율적
- 자동 버전 관리

**단점:**
- 버전 ID가 복잡함 (사람이 읽기 어려움)
- 롤백 시 모든 파일 개별 처리 필요
- 웹사이트 호스팅과 복잡한 통합

### 2. CloudFront Origin 전환
CloudFront에서 Origin을 동적으로 전환

**구조:**
```
CloudFront Distribution
├── Origin 1: s3://bucket/releases/v1.0.0/
├── Origin 2: s3://bucket/releases/v1.0.1/
└── Origin 3: s3://bucket/releases/v1.0.2/ ← 활성
```

**장점:**
- 즉시 전환 (캐시 무효화만)
- 트래픽 분산 가능
- A/B 테스트 용이

**단점:**
- CloudFront 필수 (비용 증가)
- 설정 복잡도 증가
- AWS API를 통한 Origin 변경 필요

### 3. 별도 버킷 방식
각 버전을 별도 버킷에 저장

**구조:**
```
s3://myapp-v1-0-0/
s3://myapp-v1-0-1/
s3://myapp-v1-0-2/ ← 활성 (DNS 포인팅)
```

**장점:**
- 완전한 격리
- 권한 관리 세밀화
- 버전별 독립적 설정

**단점:**
- 버킷 관리 복잡
- DNS/도메인 전환 필요
- 버킷 수 제한 고려 필요

## 업계 사용 패턴

### 스타트업/개인 프로젝트
- **폴더 기반 버저닝** (현재 구현)
- 단순하고 직관적
- 관리 오버헤드 최소

### 중견기업
- **CloudFront + 폴더 기반** 조합
- 성능과 관리의 균형
- CDN 혜택 + 명확한 버전 관리

### 대기업
- **복합적 접근**
- Blue/Green 배포
- 다중 리전 복제
- 카나리 배포
- 자동화된 롤백

## 현재 구현의 적절성

### 우리 프로젝트에 적합한 이유:
1. **적정 규모**: 개인/스타트업 프로젝트에 최적화
2. **단순성**: 복잡한 인프라 없이도 버저닝 구현
3. **투명성**: 각 버전을 명확히 볼 수 있음
4. **롤백 용이성**: 폴더 복사만으로 즉시 롤백
5. **비용 효율성**: 추가 AWS 서비스 불필요

### 향후 개선 방향:
1. **스토리지 최적화**: 변경된 파일만 복사하는 diff 기반 배포
2. **CloudFront 통합**: 성능 향상을 위한 CDN 추가
3. **자동화 강화**: GitHub Actions를 통한 완전 자동 배포
4. **모니터링**: 배포 성공/실패 알림 시스템

## 결론

현재 구현한 **폴더 기반 버저닝**은 우리 프로젝트 규모와 요구사항에 매우 적합합니다. 
복잡성과 기능성의 균형을 잘 맞춘 실용적인 선택이며, 대부분의 스타트업과 개인 프로젝트에서 
널리 사용되는 검증된 패턴입니다.
